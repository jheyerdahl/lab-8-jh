---
title: "Lab8"
author: "Justin Heyerdahl"
date: "3/8/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Load the packages
```{r}
library(tidyverse)
library(sf)
library(tmap)
library(leaflet)
library(spatstat)
library(maptools)
```

##Column graph of Texas oil spills
```{r}
oil_spills <- read_csv("oil_spills.csv")

df <- oil_spills %>%
  #If you're columns don't have nice names to work with, you can always just bound the name with ' ', or start typing the column name and it'll come up as an option, and R will add ' ' for you.
  #Filter for only oil spills that occured in Texas prior to 2017.
  filter(`Accident State` == "TX" & `Accident Year` < 2017) %>%
  group_by(`Accident Year`) %>%
  #Use summarise to create a new grouping called Loss that is the sum of 'Net Loss (Barrels)'.
  summarise(Loss = sum(`Net Loss (Barrels)`))

#Rename columns to make life easier.
colnames(df) <- c("Year", "Loss")

#Create a simple column graph of net Loss of oil spills in Texas over Years 2010 - 2016.
ggplot(df, aes(x = Year, y = Loss)) +
  geom_col()
```

##Make a leaflet plot of spill locations in TX in 2016.
```{r}
df_loc <- oil_spills %>%
  filter(`Accident State` ==  "TX" & `Accident Year` == 2016) %>%
  #Keep only columns for the names below.
  select(Latitude, Longitude, `Net Loss (Barrels)`)

#Fix the column names to more data analysis friendly names.
colnames(df_loc) <-c("latitude", "longitude", "net_loss")

#Turn the data into simple features spatial data and assign coordinates. Long first, lat, second. 
oil_sf <- st_as_sf(df_loc, coords = c("longitude", "latitude"), crs = 4326)

#Make a leaflet map.
leaflet(oil_sf) %>%
  #Add a basemap
  addTiles() %>%
  addMarkers()
  
```

##Make a tmap plot with the Texas state shapefile.
```{r}
#Read in the state shapefile layers. st_read calls simple features or layers from a file or database.
#Make sure the entire shapefile is in the working directory so you can called it with dsn = ".", and then specify the layers all begin with "states."
states <- st_read(dsn = ".", layer = "states")

tex_border <- states %>%
  #Filter for only rows with the name Texas.
  filter(STATE_NAME == "Texas") %>%
  #You can easily specify your projection by using st_transform, and referencing the CSR/ESPG number.
  #Make sure that is matches whatever projection your data points are in.
  st_transform(4326)

#You can ask R to make a super simple plot, and R will take a shot at it.
#plot(tex_border)

#Let's add points to this map.
tm_shape(tex_border) +
  #Specify we want to display a polygon
  tm_polygons() + 
  #Specify to add shapes from database oil_sf.
  tm_shape(oil_sf) +
  #Specify the type of points to display as these new shapes.
  tm_dots(size = 0.3)
```

##Convert the data to spatial points patterns (a combination of the point data and the bounding window). We need to know where the actual observations are , but also some kind of bounding window in which we can evaluate them.
```{r}

#Convert a dataframe into simple features by using as(), the name of the data, and specify that it is should be "Spatial".
spill_sp <- as(oil_sf, "Spatial")
#Conver this new spatial dataframe into a point pattern, "ppp".
spill_ppp <- as(spill_sp, "ppp")

#Take the texas border and make it spatial to use as a bounding window.
tx_sp <- as(tex_border, "Spatial")
#Take the new Texas spatial information and specify it as a window for analysis, "owin".
tx_owin <- as(tx_sp, "owin")

#Tell R to use columns x and y in spill_ppp for coordinates, and display them in the window defined by tx_owin.
all_ppp <- ppp(spill_ppp$x, spill_ppp$y, window = tx_owin)
#Some points might lie just beyond the boundary and won't be displayed. R automaticlaly omits points that don't align between the point pattern and the window. 
```

##A kernel density plot:
```{r}

#Create a density plot of all the point infromation we just created and make the bubbles 0.4. Make sure to be careful about what you specify the bin width to be. Play with using 0.4 and 0.1, and notice the difference in the map output. It conveys information a little differently, right?
plot(density(all_ppp, sigma = 0.1))
```

